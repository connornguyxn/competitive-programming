#if DEBUG
    #include "lib/include/debug.h"
    #define TASK "test"
#else
    #pragma GCC optimize("O3,unroll-loops,inline")
    #include <bits/stdc++.h>
    #define TASK "gplant"
#endif
using namespace std;
#define ll long long
#define ull unsigned long long
#define pii pair<int, int>
#define pll pair<long long, long long>
#define fi first
#define se second
#define str string
#define nl '\n'
#define sp ' '
#define mask(POS) (1ULL << (POS))
#define st_getbit(MASK, POS) ((MASK >> POS) & 1)
#define all(VAR) (VAR).begin(), (VAR).end()
const int N = 1e5 + 1;
const ull MOD = 1e9 + 7;
const int INF = 1e9 + 1;
const ll INFLL = 1e18 + 1;
// directions = left, up, right, down, upper_l, upper_r, lower_r, lower_l
const int dx[8] = {0, -1, 0, 1, -1, -1, 1, 1};
const int dy[8] = {-1, 0, 1, 0, -1, 1, 1, -1};
template<typename tVar, typename tVal>
void mnmz(tVar &var, tVal val) { if (val < var) var = val; }
template<typename tVar, typename tVal>
void mxmz(tVar &var, tVal val) { if (val > var) var = val; }

// gplant
// graph, hld, segtree

int n;
array<vector<int>, N> adj;
////////////////
int hld_cur_pos = 0;
array<int, N> par, depth, heavy, head, pos;
////////////////
array<int, N * 4> st, buf, cnt;
////////////////////////////////////////
int hld_dfs(int cur) {
    int size = 1, mx_size = 0;
    
    for (int nxt : adj[cur]) {
        if (nxt == par[cur]) continue;
        
        par[nxt] = cur;
        depth[nxt] = depth[cur] + 1;
        
        int nxt_size = hld_dfs(nxt);
        size += nxt_size;
        
        if (nxt_size >= mx_size) {
            heavy[cur] = nxt;
            mx_size = nxt_size;
        }
    }
    
    return size;
}
////////////////
void hld_decompose(int cur, int cur_head) {
    head[cur] = cur_head;
    pos[cur] = hld_cur_pos++;
    
    if (heavy[cur]) hld_decompose(heavy[cur], cur_head);
    
    for (int nxt : adj[cur]) {
        if (nxt == par[cur] || nxt == heavy[cur]) continue;
        hld_decompose(nxt, nxt);
    }
}
////////////////////////////////////////
void st_build(int tl, int tr, int cur = 1) {
    if (tl == tr) {
        cnt[cur] = 1;
    } else {
        int tm = (tl + tr) / 2;
        st_build(tl, tm, cur * 2);
        st_build(tm + 1, tr, cur * 2 + 1);
        
        cnt[cur] = cnt[cur * 2] + cnt[cur * 2 + 1];
    }
}
////////////////
void st_push(int cur) {
    st[cur * 2] += buf[cur] * cnt[cur * 2];
    st[cur * 2 + 1] += buf[cur] * cnt[cur * 2 + 1];
    
    buf[cur * 2] += buf[cur];
    buf[cur * 2 + 1] += buf[cur];
    
    buf[cur] = 0;
}
////////////////
void st_update(int l, int r, int val, int tl, int tr, int cur = 1) {
    if (l > r) return;
    
    if (l == tl && r == tr) {
        st[cur] += val * (r - l + 1);
        buf[cur] += val;
    } else {
        st_push(cur);
        
        int tm = (tl + tr) / 2;
        st_update(l, min(r, tm), val, tl, tm, cur * 2);
        st_update(max(l, tm + 1), r, val, tm + 1, tr, cur * 2 + 1);
        
        st[cur] = st[cur * 2] + st[cur * 2 + 1];
    }
}
////////////////
int st_get(int l, int r, int tl, int tr, int cur = 1) {
    if (l > r) return 0;
    
    if (l == tl && r == tr) {
        return st[cur];
    } else {
        st_push(cur);
        
        int tm = (tl + tr) / 2;
        int lq = st_get(l, min(r, tm), tl, tm, cur * 2);
        int rq = st_get(max(l, tm + 1), r, tm + 1, tr, cur * 2 + 1);
        
        return lq + rq;
    }
}
////////////////////////////////////////
void update(int u, int v) {
    for (; head[u] != head[v]; v = par[head[v]]) {
        if (depth[head[u]] > depth[head[v]]) swap(u, v);
        
        // db(pos[head[v]], pos[v]);
        st_update(pos[head[v]], pos[v], 1, 0, n - 1);
    }
    
    if (depth[u] > depth[v]) swap(u, v);
    
    // db(pos[u] + 1, pos[v]);
    st_update(pos[u] + 1, pos[v], 1, 0, n - 1);
}
////////////////
int query(int u, int v) {
    int res = 0;
    
    for (; head[u] != head[v]; v = par[head[v]]) {
        if (depth[head[u]] > depth[head[v]]) swap(u, v);
        
        // db(pos[head[v]], pos[v]);v = par[head[v]];
        res += st_get(pos[head[v]], pos[v], 0, n - 1);
    }
    
    if (depth[u] > depth[v]) swap(u, v);
    
    // db(pos[u] + 1, pos[v]);
    res += st_get(pos[u] + 1, pos[v], 0, n - 1);
    
    return res;
}
////////////////////////////////////////
int main() {
    if (fopen(TASK".inp", "r")) {
        freopen(TASK".inp", "r", stdin);
        // freopen(TASK".out", "w", stdout);
    };
    cin.tie(0) -> sync_with_stdio(0);
    ////////////////
    int tc;
    cin >> n >> tc;
    
    for (int i = 1; i < n; i++) {
        int u, v;
        cin >> u >> v;
        adj[u].push_back(v);
        adj[v].push_back(u);
    }
    
    hld_dfs(1);
    hld_decompose(1, 1);
    
    st_build(0, n - 1);
    
    while (tc--) {
        char c;
        cin >> c;
        
        int u, v;
        cin >> u >> v;
        // db(c, u, v);
        
        if (c == 'P') {
            update(u, v);
        } else {
            cout << query(u, v) << nl;
        }
    }
    ////////////////
    return 0;
}
/*
000000000000000000000000000000000000000000011111111100000000000000000000000000000000000000
0000000000000000000000000000000000001111.............1111111000000000000000000000000000000
00000000000000000000000000000000011.. .....11111111.........111000000000000000000000000000
000000000000000000000000000000011.  .1111111111111111111111.. .110000000000000000000000000
0000000000000000000000000000001. ..111111111111111111111111111. .1100000000000000000000000
000000000000000000000000000001. .111111111111111111111111111111. .110000000000000000000000
00000000000000000000000000001. .111111.............11111111111111. .1000000000000000000000
00000000000000000000000000001  111.   ..............   ...11111111. .100000000000000000000
0000000000000000000000000001. .11.  ..11111111111111111..  .1111111. .10000000000000000000
0000000000000000000000000001  111. ..11111111111111111111.  .1111111. .1000000000000000000
000000000000000000000000001. .111.  ..1111111111111111111.. .11111111. .100000000000000000
000000000000000000000000001. 11111.   ...11111111111111...  .11111111. .100000000000000000
000000000000000000000000011 .1111111..   ..............   .11111111111. 110000000000000000
00000000000000000000000001. .1111111111.................11111111111111. .10000000000000000
00000000000000000000000001 .1111111111111111111111111111111111111111111  10000000000000000
0000000000000000000000001. .1111111111111111111111111111111111111111111. .1000000000000000
0000000000000000000000001. 11111111111111111111111111111111111111111111. .1000000000000000
000000000000000000000001. .11111111111111111111111111111111111111111111. .1000000000000000
000000000000000000000001. .111111111111111111111111111111111111111111111 .1000000000000000
000000000000000000000011 .1111111111111111111111111111111111111111111111 .1000000000000000
00000000000000000000001. .1111111111111111111111111111111111111111111111. 1000000000000000
00000000000000000000001. 11111111111111111111111111111111111111111111111. 1000000000000000
0000000000000000000001. .11111111111111111111111111111111111111111111111. 1100000000000000
0000000000000000000001. .11111111111111111111111111111111111111111111111. 1100000000000000
0000000000000000000011 .111111111111111111111111111111111111111111111111. 1100000000000000
000000000000000000001. .111111111111111111111111111111111111111111111111. 1100000000000000
000000000000000000001 .1111111111111111111111111111111111111111111111111  1000000000000000
00000000000000000001. .1111111111111111111111111111111111111111111111111 .1000000000000000
00000000000000000001. 11111111111111111111.........11111111111111111111. .1000000000000000
0000000000000000001. .111111111111................... .1111111111111111. .1000000000000000
0000000000000000001. .111111111....111111111111111111. .111111111111111. .1000000000000000
0000000000000000011 .111111111. .100000000000000000001  111111111111111. .1000000000000000
000000111111111111. .111111111. .100000000000000000001  111111111111111. .1000000000000000
00111...............11111111111 .100000000000000000001 .111111111111111. .1000000000000000
001. ..111111111111111111111111. 110000000000000000001  111111111111111. .1000000000000000
001. 11111111111111111111111111. .10000000000000000001  111111111111111. .1000000000000000
001. .1111111111111111111111111. .10000000000000000001 .111111111111111. .1000000000000000
00011. ..11111111111111111111..  .1000000000111111111. .111111111111111 .10000000000000000
0000011.. ................. ...11100000111........... ..11111111111111. .10000000000000000
0000000111111...........111111000000011. ...11111111111111111111111111  110000000000000000
00000000000000000000000000000000000001. .111111111111111111111111111.  .100000000000000000
000000000000000000000000000000000000011. .11111111111111111111111.. ..11000000000000000000
00000000000000000000000000000000000000111.. ......111111111.... ...11000000000000000000000
00000000000000000000000000000000000000000111111...............1111000000000000000000000000
000000000000000000000000000000000000000000000000011111111111100000000000000000000000000000
*/